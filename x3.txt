// Types
interface Book {
    title?: string | null;
    author?: string | null;
    isbn?: string | null;
    pubDate: string;
    genre?: string | null;
    price?: number | null;
    purchaseLink?: string | null;
    bookType?: string | null;
    isLocal?: boolean;
}

// Validation Service
class BookValidator {
    validateISBN(isbn: string): boolean {
        return /^\d+$/.test(isbn);
    }

    validateBook(book: Partial<Book>): string[] {
        const errors: string[] = [];
        if (!book.title) errors.push("Title is required");
        if (!book.author) errors.push("Author is required");
        if (!book.isbn) errors.push("ISBN is required");
        if (!this.validateISBN(book.isbn || "")) errors.push("ISBN must contain only numeric characters");
        return errors;
    }
}



// Storage Service
class BookStorageService {
    private readonly STORAGE_KEY = "books";

    getBooks(): Book[] {
        const books = JSON.parse(localStorage.getItem(this.STORAGE_KEY) || "[]");
        // Mark books as local
        return books.map((book: any) => ({ ...book, isLocal: true }));
    }

    saveBooks(books: Book[]): void {
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(books));
    }

    addBook(book: Book): void {
        const books = this.getBooks();
        books.push(book);
        this.saveBooks(books);
    }

    updateBook(index: number, book: Book): void {
        const books = this.getBooks();
        books[index] = book;
        this.saveBooks(books);
    }

    deleteBook(index: number): void {
        const books = this.getBooks();
        books.splice(index, 1);
        this.saveBooks(books);
    }
}

//API Services
class BookApiService {
    private readonly API_URL = "https://jsonplaceholder.typicode.com/posts";

    async fetchApiBooks(): Promise<Book[]> {
        try {
            const response = await fetch(this.API_URL);
            if (!response.ok) throw new Error("Failed to fetch data from the server.");

            const apiBooks = await response.json();
            return apiBooks.map((item: any) => ({
                title: String(item.title || "Untitled"),
                author: "Author",
                isbn: "12",
                pubDate: "2025-01-01",
                genre: "API Genre",
                price: 20.0,
                purchaseLink: "https://www.amazon.in/s?k=books",
                bookType: "EBook",
                isLocal: false
            }));
        } catch (error) {
            console.error("Error fetching books from server:", error);
            return [];
        }
    }
}


// Book Age Calculator
class BookAgeCalculator {
    calculateBookAge(pubDate: string): string {
        const publicationDate = new Date(pubDate);
        const currentDate = new Date();
        const age = currentDate.getFullYear() - publicationDate.getFullYear();
        return age > 0 ? `${age} year(s)` : "Less than a year";
    }
}

class BookFilterService {
    filterBooks(books: Book[], searchTerm: string = "", genreFilter: string = ""): Book[] {
        return books.filter(book => {
            // Search term matching
            const searchMatch = searchTerm === "" || this.matchesSearchTerm(book, searchTerm);
            
            // Genre filtering
            const genreMatch = genreFilter === "" || this.matchesGenre(book, genreFilter);
            
            return searchMatch && genreMatch;
        });
    }

    private matchesSearchTerm(book: Book, searchTerm: string): boolean {
        const searchLower = searchTerm.toLowerCase();
        
        // Convert each property to string and handle null/undefined
        const title = String(book.title || "").toLowerCase();
        const author = String(book.author || "").toLowerCase();
        const genre = String(book.genre || "").toLowerCase();

        return (
            title.includes(searchLower) ||
            author.includes(searchLower) ||
            genre.includes(searchLower)
        );
    }

    private matchesGenre(book: Book, genreFilter: string): boolean {
        // Ensure genre is a string and handle null/undefined/non-string values
        const bookGenre = String(book.genre || "").toLowerCase();
        const filter = genreFilter.toLowerCase();
        
        // Map UI filter values to actual genre values
        switch (filter) {
            case "fiction":
                return bookGenre === "fiction" || 
                       bookGenre.includes("novel") || 
                       bookGenre.includes("fiction");
            case "non-fiction":
                return bookGenre === "non-fiction" || 
                       bookGenre.includes("non-fiction") ||
                       bookGenre.includes("nonfiction") ||
                       bookGenre.includes("biography") ||
                       bookGenre.includes("history") ||
                       bookGenre.includes("science");
            default:
                return true;
        }
    }

    sortBooks(books: Book[], sortOption: string): Book[] {
        const sortedBooks = [...books];
        if (sortOption === "asc") {
            sortedBooks.sort((a, b) => {
                const titleA = String(a.title || "").toLowerCase();
                const titleB = String(b.title || "").toLowerCase();
                return titleA.localeCompare(titleB);
            });
        } else if (sortOption === "desc") {
            sortedBooks.sort((a, b) => {
                const titleA = String(a.title || "").toLowerCase();
                const titleB = String(b.title || "").toLowerCase();
                return titleB.localeCompare(titleA);
            });
        }
        return sortedBooks;
    }
}

// UI Renderer
class BookListRenderer {
    private bookList: HTMLElement;
    private ageCalculator: BookAgeCalculator;

    constructor(bookListElement: HTMLElement) {
        this.bookList = bookListElement;
        this.ageCalculator = new BookAgeCalculator();
    }

    renderBooks(books: Book[]): void {
        this.bookList.innerHTML = "";
        
        if (books.length === 0) {
            this.bookList.innerHTML = "<tr><td colspan='8'>No books found.</td></tr>";
            return;
        }

        books.forEach((book, index) => this.renderBookRow(book, index));
    }

    private renderBookRow(book: Book, index: number): void {
        const bookAge = this.ageCalculator.calculateBookAge(book.pubDate);
        const row = document.createElement("tr");
        
        row.innerHTML = `
            <td>${book.title}</td>
            <td>${book.author}</td>
            <td>${book.isbn || "N/A"}</td>
            <td>${book.pubDate || "N/A"}</td>
            <td>${book.genre || "N/A"}</td>
            <td>${book.bookType || "N/A"}</td>
            <td>${book.price ? `$${book.price}` : "N/A"}</td>
            <td>${bookAge}</td>
            <td><a href="${book.purchaseLink}" target="_blank">Purchase</a></td>
            <td>
                <div class="button-container">
                    <button class="edit-btn" data-index="${index}">Edit</button>
                    <button class="delete-btn" data-index="${index}">Delete</button>
                    <button class="details-btn" data-index="${index}">Details</button>
                </div>
            </td>
        `;

        this.bookList.appendChild(row);
    }
}

// Form Handler
class BookFormHandler {
    private validator: BookValidator;
    private storageService: BookStorageService;

    constructor() {
        this.validator = new BookValidator();
        this.storageService = new BookStorageService();
    }

    handleSubmit(e: Event): void {
        e.preventDefault();

        const formData = this.getFormData();
        const errors = this.validator.validateBook(formData);

        if (errors.length > 0) {
            alert(errors.join("\n"));
            return;
        }

        const editIndex = (document.getElementById("edit-index") as HTMLInputElement).value;

        if (editIndex !== "") {
            this.storageService.updateBook(parseInt(editIndex), formData as Book);
        } else {
            this.storageService.addBook(formData as Book);
        }

        alert("Book saved successfully!");
        window.location.href = "index.html";
    }

    private getFormData(): Partial<Book> {
        return {
            title: (document.getElementById("title") as HTMLInputElement).value,
            author: (document.getElementById("author") as HTMLInputElement).value,
            isbn: (document.getElementById("isbn") as HTMLInputElement).value,
            pubDate: (document.getElementById("pub-date") as HTMLInputElement).value,
            genre: (document.getElementById("genre") as HTMLInputElement).value,
            price: parseFloat((document.getElementById("price") as HTMLInputElement).value),
            purchaseLink: (document.getElementById("purchase-link") as HTMLInputElement).value,
            bookType: (document.getElementById("book-type") as HTMLInputElement).value
        };
    }

    prefillForm(): void {
        const editData = JSON.parse(localStorage.getItem("editBook") || "{}");
        if (!editData.book) return;

        const { book, index } = editData;
        Object.entries(book).forEach(([key, value]) => {
            const element = document.getElementById(key) as HTMLInputElement;
            if (element) element.value = value as string;
        });
        
        (document.getElementById("edit-index") as HTMLInputElement).value = index;
        localStorage.removeItem("editBook");
    }
}

// Main Controller
class BookManagerController {
    private storageService: BookStorageService;
    private apiService: BookApiService;
    private filterService: BookFilterService;
    private renderer: BookListRenderer;
    private currentSearchTerm: string = "";
    private currentGenreFilter: string = "";
    private currentSortOption: string = "";
    private allBooks: Book[] = [];

    constructor(bookListElement: HTMLElement) {
        this.storageService = new BookStorageService();
        this.apiService = new BookApiService();
        this.filterService = new BookFilterService();
        this.renderer = new BookListRenderer(bookListElement);
        this.initializeEventListeners();
        this.initializeBooks(); // Call this immediately in constructor
    }

    private async initializeBooks(): Promise<void> {
        try {
            // First load books from localStorage
            const localBooks = this.storageService.getBooks();
            
            // Then fetch books from API
            const apiBooks = await this.apiService.fetchApiBooks();
            
            // Combine both sets of books
            this.allBooks = [...localBooks, ...apiBooks];
            
            // Apply any current filters and render
            await this.loadBooks();
        } catch (error) {
            console.error("Error initializing books:", error);
            // If API fails, at least show localStorage books
            this.allBooks = this.storageService.getBooks();
            await this.loadBooks();
        }
    }

    private async loadBooks(): Promise<void> {
        // Filter and sort the existing books
        let filteredBooks = this.filterService.filterBooks(
            this.allBooks,
            this.currentSearchTerm,
            this.currentGenreFilter
        );

        filteredBooks = this.filterService.sortBooks(filteredBooks, this.currentSortOption);
        
        // Render the filtered and sorted books
        this.renderer.renderBooks(filteredBooks);
    }

    private async refreshBooks(): Promise<void> {
        // Update local books
        const localBooks = this.storageService.getBooks();
        
        // Keep API books but update local books
        const apiBooks = this.allBooks.filter(book => !book.hasOwnProperty('isLocal'));
        this.allBooks = [...localBooks, ...apiBooks];
        
        await this.loadBooks();
    }

    private initializeEventListeners(): void {
        // Search
        const searchBar = document.getElementById("search-bar") as HTMLInputElement;
        searchBar?.addEventListener("input", (e) => {
            this.currentSearchTerm = (e.target as HTMLInputElement).value;
            this.loadBooks();
        });

        // Filters
        document.getElementById("filter-fiction")?.addEventListener("click", () => {
            this.currentGenreFilter = "fiction";
            this.loadBooks();
        });

        document.getElementById("filter-non-fiction")?.addEventListener("click", () => {
            this.currentGenreFilter = "non-fiction";
            this.loadBooks();
        });

        document.getElementById("clear-filters")?.addEventListener("click", () => {
            this.currentSearchTerm = "";
            this.currentGenreFilter = "";
            this.currentSortOption = "";
            if (searchBar) searchBar.value = "";
            this.loadBooks();
        });

        // Sorting
        document.getElementById("sort-asc")?.addEventListener("click", () => {
            this.currentSortOption = "asc";
            this.loadBooks();
        });

        document.getElementById("sort-desc")?.addEventListener("click", () => {
            this.currentSortOption = "desc";
            this.loadBooks();
        });

        // Book actions
        document.addEventListener("click", async (e) => {
            const target = e.target as HTMLElement;
            if (!target.dataset.index) return;

            const index = parseInt(target.dataset.index);
            if (target.classList.contains("edit-btn")) await this.handleEdit(index);
            if (target.classList.contains("delete-btn")) await this.handleDelete(index);
            if (target.classList.contains("details-btn")) this.handleDetails(index);
        });
    }

    private async handleEdit(index: number): Promise<void> {
        const books = this.storageService.getBooks();
        localStorage.setItem("editBook", JSON.stringify({ book: books[index], index }));
        window.location.href = "add-book.html";
    }

    private async handleDelete(index: number): Promise<void> {
        this.storageService.deleteBook(index);
        await this.refreshBooks();
    }

    private handleDetails(index: number): void {
        const book = this.allBooks[index];
        const ageCalculator = new BookAgeCalculator();
        const bookAge = ageCalculator.calculateBookAge(book.pubDate);

        alert(`
            Title: ${book.title}
            Author: ${book.author}
            ISBN: ${book.isbn || "N/A"}
            Publication Date: ${book.pubDate || "N/A"}
            Age: ${bookAge}
            Genre: ${book.genre || "N/A"}
            Book Type: ${book.bookType || "N/A"}
            Price: ${book.price ? `$${book.price}` : "N/A"}
            Purchase Link: ${book.purchaseLink}
        `);
    }
}


// Initialize application
document.addEventListener("DOMContentLoaded", () => {
    const bookList = document.getElementById("book-list");
    if (bookList) {
        new BookManagerController(bookList);
    }

    const bookForm = document.getElementById("book-form");
    if (bookForm) {
        const formHandler = new BookFormHandler();
        formHandler.prefillForm();
        bookForm.addEventListener("submit", (e) => formHandler.handleSubmit(e));
    }
});